# Нельзя повторять ход противника
def f(s,m,p): # p - аргумент, который запоминает ходы, и нужен для проверки
    if s>=140: return m%2==0
    if m==0: return 0
    h = []
    if p!='+1': h+=[f(s+1,m-1,'+1')] # тут расписываются варианты ходов игроков
    if p!='+2': h+=[f(s+2,m-1,'+2')]
    if p!='*3': h+=[f(s*3,m-1,'*3')]
    return any(h) if m%2!=0 else all(h)

print('19', [s for s in range(1,140) if f(s,2,'')])
print('20', [s for s in range(1,140) if not f(s,1,'') and f(s,3,'')])
print('21', [s for s in range(1,140) if not f(s,2,'') and f(s,4,'')])


# Нельзя повторять свой предыдущий ход
def f(s,m,p1,p2): # p1 - ход предыдущего игрока, p2 - наш предыдущий ход
    if s>=121: return m%2==0
    if m==0: return 0
    h = []
    if p2!='+2': h+=[f(s+1,m-1,'+2',p1)] # p1,p2 -> +2,p1 т.к. мы забываем старый ход и делаем сдвиг на ход
    if p2!='+5': h+=[f(s+2,m-1,'+5',p1)]
    if p2!='+12': h+=[f(s+2,m-1,'+12',p1)]
    if p2!='*2': h+=[f(s*3,m-1,'*2',p1)]
    return any(h) if m%2!=0 else all(h)

print('19', [s for s in range(1,140) if f(s,2,'','')])
print('20', [s for s in range(1,140) if not f(s,1,'','') and f(s,3,'','')])
print('21', [s for s in range(1,140) if not f(s,4,'','') and f(s,6,'','')])

# Удвоение камней можно выполнять если в куче в данный момент нечётное кол-во камней
def f(s,m):
    if s>=22: return m%2==0
    if m==0: return 0
    h = [f(s+1,m-1),f(s+2,m-1)] # пишем известные нам ходы
    if s%2!=0: h+=[f(s*2,m-1)] # добавляем если число камней в данный момент нечётное
    return any(h) if m%2!=0 else all(h)
    
print('19', [s for s in range(1,22) if not f(s,2) and f(s,4)]) 
print('20', [s for s in range(1,22) if not f(s,1) and f(s,3)])
print('21', [s for s in range(1,22) if not f(s,3) and f(s,5)])

# После каждого из 3-х ходов в куче должно быть нечётное кол-во камней
def f(s,m):
    if s>=51: return m%2==0
    if m==0: return 0
    h = []
    if (s+1)%2!=0: h+=[f(s+1,m-1)] # проверяем что после каждого хода остаётся нечётное кол-во камней
    if (s+3)%2!=0: h+=[f(s+3,m-1)]
    if s*2%2!=0: h+=[f(s*2,m-1)] # скобки убрались т.к. сначал выполняется умножение
    return any(h) if m%2!=0 else all(h)

print('19', [s for s in range(1,51) if f(s,2)])
print('20', [s for s in range(1,51) if not f(s,1) and f(s,3)])
print('21', [s for s in range(1,51) if not f(s,2) and f(s,4)])

# Две кучи. За один ход игрок может добавить в меньшую кучу ... камней. Изменять кол-во в большей куче нельзя. Игра заканчивается, когда кол-ко в кучах становится равным
# № 6103 (А. Богданов)
def f(a,b,m):
    if a==b: return m%2==0
    if m==0: return 0
    if a<b: h = [f(a+1,b,m-1), f(a+3,b,m-1)]
    if b<a: h = [f(a,b+1,m-1), f(a,b+3,m-1)]
    return any(h) if m%2!=0 else all(h)

print('19', [s for s in range(1,24) if not f(13,s,0) and f(13,s,2)]) # Или if f(13,s,2) if s!=13; Сделали так, т.к. там исходя из условия так необходимо
print('20', [s for s in range(1,24) if not f(13,s,1) and f(13,s,3)])
print('21', [s for s in range(1,24) if not f(13,s,2) and f(13,s,4)])

# За один ход игрок может добавить в большую кучу любое кол-во камней от 1 до 3 и удвоитьь кол-во в меньшей куче. Если кучи содержат равное кол-во камней, можно добавить в любую из них от одного до трёх камней, удвоение в этой ситуации запрещено.
# Игра завершается, когда в одной из куч камней не менее 78
# № 6496
def f(a,b,m):
    if a>=78 or b>=78: return m%2==0
    if m==0: return 0
    if a<b: h = [f(a,b+1,m-1),f(a,b+2,m-1),f(a,b+3,m-1),f(a*2,b,m-1)]
    if a>b: h = [f(a+1,b,m-1),f(a+2,b,m-1),f(a+3,b,m-1),f(a,b*2,m-1)]
    if a==b: h = [f(a+1,b,m-1),f(a+2,b,m-1),f(a+3,b,m-1)] # сказано добавлять в любую из куч, ну а мы для определённости добавляем в 1
    return any(h) if m%2!=0 else all(h)

print('19', min([a+b for a in range(1,78) for b in range(1,78) if f(a,b,1)])) # Известно, что Петя смог выиграть первым ходом. Какое наименьшее число камней могло быть суммарно в двух кучах
print('20', [s for s in range(1,78) if not f(25,s,1) and f(25,s,3)])
print('21', [s for s in range(1,78) if not f(69,s,2) and f(69,s,4)])

# СУПЕРХОД
# №5025 (PRO100 ЕГЭ)
def f(s,m,p): # p - аргумент, отвечающий за то, сделан был суперход или нет
    if s>=20: return m%2==0
    if m==0: return 0
    h = [f(s+2,m-1,p), f(s*2,m-1,p)]
    if p!=1: h += [f(s,m-1,1)]
    return any(h) if m%2!=0 else all(h)
    
print('19', [s for s in range(1,20) if f(s,2,0)]) # третий аргумент в f() 0 т.к суперход ещё не сделан
print('20', [s for s in range(1,20) if not f(s,1,0) and f(s,3,0)])
print('21', [s for s in range(1,20) if f(s,20,0)]) # "Найдите наибольшее и наименьшее значение s, при которых у Вани есть выигрышная стратегия." То есть нужно перебрать где то 20 ходов (10 ходов Вани) чтобы узнать его выигрышные стратегии
