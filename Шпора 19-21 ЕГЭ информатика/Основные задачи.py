# КАМНИ
# Одна куча камней
def f(s,m): # s - камни (они будут  в range()); m - кол-во ходов (зависит от условия задачи!: m=1 - первый ход Пети; m=2 - первый ход Вани; m=3 - второй ход Пети; m=4 - первый или второй ход Вани) - но это если первый ход делает Петя!
    if s>=25: return m%2==0 # s>=25 - условие выигрыша!; после return - чтобы глубкого не копать если есть выигрышная стратегия за меньшее кол-во ходов
    if m==0: return 0 # чтобы не копать ещё глубже
    h = [f(s+2,m-1), f(s*2,m-1)] # в первом аргументе f() к s приписываем ходы игроков. В данном случае: за один ход игрок добавляет в кучу 2 камня (s+2) или увеличивает кол-во в 2 раза (s*2); m-1 - это уменьшение ходов на 1 (ход типа сделан)
    return any(h) if (m-1)%2==0 else all(h) # объяснение с any() и all() лучше посмотреть в нужном разделе видео Алексея Кабанова т.к. он там наглядно показывает работу этой рекурсивной функции

print('19)',[s for s in range(1,25) if f(s,2)]) # f(s,2) - Ваня выиграет первым ходом; в range() пишется кол-во камней в начальный момент! Например здесь в начальный момент в куче 1<=s<=24 (1,25 т.к. 25 не включительно!); '19)' - это номер задания
print('20)',[s for s in range(1,25) if not f(s,1) and f(s,3)]) # not f(s,1) - Петя не может выиграть за один ход; f(s,3) - ПЕТЯ может выиграть своим ВТОРЫМ ХОДОМ независимо как будет ходить Ваня
print('21)',[s for s in range(1,25) if not f(s,2) and f(s,4)]) # not f(s,2) - У Вани нет выигрышной стратегии за один ход; f(s,4) - Ваня может выиграть первым или вторым ходом
# Если в условии к примеру третий ход Вани - вспоминаем, что нечётные ходы - Пети (начиная с 1), чётные - Вани (начиная с 2) и умножаем их на кол-во ходов). То есть - третий ход Вани - это m=6 

# Одна куча камней (с проигрышем) - ну типа доп. условие что если кол-во перевалит за то что в условии, то проигрыш
def f(s,m):
    if 45<=s<=112: return m%2==0 # поменялось условие выигрыша!
    if s>112: return m%2!=0 # условие проигрыша, причём тут m%2 уже !=0!
    if m==0: return 0
    h = [f(s+2,m-1), f(s*3,m-1)]
    return any(h) if (m-1)%2==0 else all(h)

print('19)',[s for s in range(1,45) if f(s,2)])
print('20)',[s for s in range(1,45) if not f(s,1) and f(s,3)])
print('21)',[s for s in range(1,45) if not f(s,2) and f(s,4)])

# Две кучи камней
def f(a,b,m): # Тут уже три аргумента т.к. два первых - это две кучи камней!
    if a+b>=45: return m%2==0 # условие под условие задачи
    if m==0: return 0
    h = [f(a+1,b,m-1),f(a*3,b,m-1),f(a,b+1,m-1),f(a,b*3,m-1)] # Тут АККУРАТНО переписали условие для двух куч камней - то есть поочерёдного шаги игрока для двух куч камней
    # Если в условии написано "добавить в меньшую кучу" нужно написать конструкцию (к примеру!)
    # if a<b: h = [f(a+1,b,m-1),f(a+3,b,m-1)]
    #else: h = [f(a,b+1,m-1),f(a,b+3,m-1)]
    return any(h) if (m-1)%2==0 else all(h)

print('19)',[s for s in range(1,41) if f(4,s,2)]) # тут в первой куче в условии сказано что первоначально лежит 4 камня;
# Если в условии сказано "после неудачного хода" - значит, смотря результат этого задания, нужно в последней строчке (в последнем return) функции f() последний all(h) поменять на any(h). НО ЭТО ВРЕМЕННО И ЕДИНОРАЗОВО! ТОЛЬКО ДЛЯ ЭТОГО УСЛОВИЯ!
print('20)',[s for s in range(1,41) if not f(4,s,1) and f(4,s,3)])
print('21)',[s for s in range(1,41) if not f(4,s,2) and f(4,s,4)])

# Две кучи камней (с уменьшением)
def f(a,b,m):
    if a+b<=20: return m%2==0
    if m==0: return 0
    h = [f(a-1,b,m-1),f((a+1)//2,b,m-1),f(a,b-1,m-1),f(a,(b+1)//2,m-1)] # (a+1)//2 и (b+1)//2 т.к в условии было сказано "или уменьшить кол-во камней в два раза (если кол-во камней в куче нечётное, остаётся на 1 камень больше, чем убирается)"
    return any(h) if (m-1)%2==0 else all(h)

print('19)',[s for s in range(11,1000) if f(10,s,2)]) # про range(11,1000): в условии было сказано "во второй куче s>10" => от 11 и до неизвестного кол-ва. Спокойно делаем до 1000, т.к. быстро перебирается
print('20)',[s for s in range(11,1000) if not f(10,s,1) and f(10,s,3)])
print('21)',[s for s in range(11,1000) if not f(10,s,2) and f(10,s,4)])
